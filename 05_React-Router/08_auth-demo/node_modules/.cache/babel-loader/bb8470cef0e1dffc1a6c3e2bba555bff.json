{"ast":null,"code":"var _jsxFileName = \"D:\\\\\\u524D\\u7AEF\\u5B66\\u4E60\\\\00-react\\\\00-React\\\\05_React-Router\\\\06_router-v5\\\\src\\\\App.js\";\nimport React from 'react';\nimport { Route } from 'react-router-dom';\nimport Home from './Components/Home';\nimport About from './Components/About';\nimport Menu from './Components/Menu';\nimport Students from './Components/Students';\n/*\r\ncomponent用来指定路由匹配后被挂载的组件\r\n    component需要直接传递组件的类\r\n    通过component构建的组件，它会自动创建组件并且会自动传递参数(所以不能直接写JSX)\r\n        match -- 匹配的信息 {path: '/about', url: '/about', isExact: true, params: {…}}\r\n            isExact 检查路径是否完全匹配\r\n            params 请求的参数\r\n        location -- 地址信息 {pathname: '/about', search: '', hash: '', state: null}\r\n        history -- 控制页面的跳转  {length: 2, action: 'PUSH', location: {…}, createHref: ƒ, push: ƒ, …}\r\n            push() 跳转页面 A->B->C 在C点回退是可以回退到B的 即会产生一个新的历史记录  \r\n            replace() 替换页面  A->B->C 是用C页面替换B页面，在C点回退是回退到A的\r\n            goBack() 回退\r\n            goForward() 前进\r\n            go(n) 根据传的数去跳转，-1即往后跳\r\n            */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App() {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Menu, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Route, {\n      exact: true,\n      path: \"/\",\n      component: Home\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Route, {\n      path: \"/about\",\n      component: About\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Route, {\n      path: \"/students/:id\",\n      children: routeProps => {\n        console.log(routeProps);\n        return /*#__PURE__*/_jsxDEV(Students, { ...routeProps\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 54,\n          columnNumber: 24\n        }, this);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 24,\n    columnNumber: 9\n  }, this);\n}\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","Route","Home","About","Menu","Students","App","routeProps","console","log"],"sources":["D:/前端学习/00-react/00-React/05_React-Router/06_router-v5/src/App.js"],"sourcesContent":["import React from 'react'\r\nimport { Route } from 'react-router-dom'\r\nimport Home from './Components/Home'\r\nimport About from './Components/About'\r\nimport Menu from './Components/Menu'\r\nimport Students from './Components/Students'\r\n/*\r\ncomponent用来指定路由匹配后被挂载的组件\r\n    component需要直接传递组件的类\r\n    通过component构建的组件，它会自动创建组件并且会自动传递参数(所以不能直接写JSX)\r\n        match -- 匹配的信息 {path: '/about', url: '/about', isExact: true, params: {…}}\r\n            isExact 检查路径是否完全匹配\r\n            params 请求的参数\r\n        location -- 地址信息 {pathname: '/about', search: '', hash: '', state: null}\r\n        history -- 控制页面的跳转  {length: 2, action: 'PUSH', location: {…}, createHref: ƒ, push: ƒ, …}\r\n            push() 跳转页面 A->B->C 在C点回退是可以回退到B的 即会产生一个新的历史记录  \r\n            replace() 替换页面  A->B->C 是用C页面替换B页面，在C点回退是回退到A的\r\n            goBack() 回退\r\n            goForward() 前进\r\n            go(n) 根据传的数去跳转，-1即往后跳\r\n            */\r\nexport default function App() {\r\n    return (\r\n        <div>\r\n            <Menu />\r\n            <Route exact path=\"/\" component={Home}></Route>\r\n            <Route path=\"/about\" component={About}></Route>\r\n            {/* /student/:id 会匹配到 /student/xxx  冒号开头后边是传的参数，存在match的params里*/}\r\n            {/* 查询字符串是在location的search内 search:\"?name=admin\" */}\r\n            {/* <Route path=\"/students/:id\" component={Students}></Route> */}\r\n\r\n            {/* 方式二 */}\r\n            {/* 用Component的一个局限是传的是类，不能用JSX，无法自定义组件的属性，所以提供了render方式 */}\r\n            {/*\r\n                render 也可以用了指定要挂载的组件\r\n                    render需要一个回调函数作为参数，回调函数的返回值会最终被挂载\r\n                    render不会自动传递三个属性 match、location、history, 是作为参数传进了回调函数中\r\n            */}\r\n            {/* <Route path=\"/students/:id\" render={(routeProps) => {\r\n                console.log(routeProps);\r\n                return <Students {...routeProps}></Students>\r\n            }}></Route> */}\r\n\r\n            {/* 方式三 */}\r\n            {/*\r\n                children 也可以用来指定被挂载的组件\r\n                    用法有两种：\r\n                        1. 和render类似，传递回调函数\r\n                            - 当children设置一个回调函数时，该组件无论路径是否匹配都会挂载\r\n                        2. 可以传递组件\r\n            */}\r\n            <Route path=\"/students/:id\" children={(routeProps) => {\r\n                console.log(routeProps);\r\n                return <Students {...routeProps}></Students>\r\n            }}></Route>\r\n        </div>\r\n    )\r\n}\r\n"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,OAAOC,KAAP,MAAkB,oBAAlB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,OAAOC,QAAP,MAAqB,uBAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASC,GAAT,GAAe;EAC1B,oBACI;IAAA,wBACI,QAAC,IAAD;MAAA;MAAA;MAAA;IAAA,QADJ,eAEI,QAAC,KAAD;MAAO,KAAK,MAAZ;MAAa,IAAI,EAAC,GAAlB;MAAsB,SAAS,EAAEJ;IAAjC;MAAA;MAAA;MAAA;IAAA,QAFJ,eAGI,QAAC,KAAD;MAAO,IAAI,EAAC,QAAZ;MAAqB,SAAS,EAAEC;IAAhC;MAAA;MAAA;MAAA;IAAA,QAHJ,eA4BI,QAAC,KAAD;MAAO,IAAI,EAAC,eAAZ;MAA4B,QAAQ,EAAGI,UAAD,IAAgB;QAClDC,OAAO,CAACC,GAAR,CAAYF,UAAZ;QACA,oBAAO,QAAC,QAAD,OAAcA;QAAd;UAAA;UAAA;UAAA;QAAA,QAAP;MACH;IAHD;MAAA;MAAA;MAAA;IAAA,QA5BJ;EAAA;IAAA;IAAA;IAAA;EAAA,QADJ;AAmCH;KApCuBD,G"},"metadata":{},"sourceType":"module"}